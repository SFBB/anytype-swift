import Foundation
import ProtobufMessages

{% for type in types.types %}
{% if type.localName == "Error" %}
extension {{ type.name }}: LocalizedError {
    public var errorDescription: String? {
        let localizeError = localizeError()
        if localizeError.isNotEmpty {
            return localizeError
        }
        return "Code: \(code), description: \(description_p)"
    }

    private func localizeError() -> String {
        switch code {
        {% for variable in type.allVariables %}
        {% if variable.name == "code" %}
            {% for case in variable.type.cases %}
            case .{{ case.name }}:
                {% if case.name == "null" or case.name == "unknownError" or case.name == "UNRECOGNIZED" or case.name == "badInput" %}
                ""
                {% else %}
                String(localizedFixedKey: "{{ type.name | replace:"Anytype_Rpc.","" | replace:".Response.Error","" }}.{{ case.name }}", table: "LocalizableError")
                {% endif %}
            {% endfor %}
        {% endif %}
        {% endfor %}        
        }
    }
}

{% endif %}
{% endfor %}

private extension String {
    // If default value is emplty, Apple return key. But we expect that localziation return empty string
    init(localizedFixedKey: StaticString, table: String? = nil) {
        let result = String(localized: localizedFixedKey, defaultValue: "", table: table)
        if result == "\(localizedFixedKey)" {
            self = ""
        } else {
            self = result
        }
    }
}