// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: pkg/lib/pb/model/protos/models.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

extension Anytype_Model_Block.Content {
    public struct Dataview {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var source: [String] = []

      public var views: [Anytype_Model_Block.Content.Dataview.View] = []

      /// do not generate changes for this field
      public var activeView: String = String()

      /// deprecated
      public var relations: [Anytype_Model_Relation] = []

      public var groupOrders: [Anytype_Model_Block.Content.Dataview.GroupOrder] = []

      public var objectOrders: [Anytype_Model_Block.Content.Dataview.ObjectOrder] = []

      public var relationLinks: [Anytype_Model_RelationLink] = []

      public var targetObjectID: String = String()

      public var isCollection: Bool = false

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct View {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var id: String = String()

        public var type: Anytype_Model_Block.Content.Dataview.View.TypeEnum = .table

        public var name: String = String()

        public var sorts: [Anytype_Model_Block.Content.Dataview.Sort] = []

        public var filters: [Anytype_Model_Block.Content.Dataview.Filter] = []

        /// relations fields/columns options, also used to provide the order
        public var relations: [Anytype_Model_Block.Content.Dataview.Relation] = []

        /// Relation used for cover in gallery
        public var coverRelationKey: String = String()

        /// Hide icon near name
        public var hideIcon: Bool = false

        /// Gallery card size
        public var cardSize: Anytype_Model_Block.Content.Dataview.View.Size = .small

        /// Image fits container
        public var coverFit: Bool = false

        /// Group view by this relationKey
        public var groupRelationKey: String = String()

        /// Enable backgrounds in groups
        public var groupBackgroundColors: Bool = false

        /// Limit of objects shown in widget
        public var pageLimit: Int32 = 0

        /// Default template that is chosen for new object created within the view
        public var defaultTemplateID: String = String()

        /// Default object type that is chosen for new object created within the view
        public var defaultObjectTypeID: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum TypeEnum: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case table // = 0
          case list // = 1
          case gallery // = 2
          case kanban // = 3
          case calendar // = 4
          case graph // = 5
          case UNRECOGNIZED(Int)

          public init() {
            self = .table
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .table
            case 1: self = .list
            case 2: self = .gallery
            case 3: self = .kanban
            case 4: self = .calendar
            case 5: self = .graph
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .table: return 0
            case .list: return 1
            case .gallery: return 2
            case .kanban: return 3
            case .calendar: return 4
            case .graph: return 5
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public enum Size: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case small // = 0
          case medium // = 1
          case large // = 2
          case UNRECOGNIZED(Int)

          public init() {
            self = .small
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .small
            case 1: self = .medium
            case 2: self = .large
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .small: return 0
            case .medium: return 1
            case .large: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public init() {}
      }

      public struct Relation {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var key: String = String()

        public var isVisible: Bool = false

        /// the displayed column % calculated based on other visible relations
        public var width: Int32 = 0

        public var dateIncludeTime: Bool = false

        public var timeFormat: Anytype_Model_Block.Content.Dataview.Relation.TimeFormat = .format12

        public var dateFormat: Anytype_Model_Block.Content.Dataview.Relation.DateFormat = .monthAbbrBeforeDay

        public var formula: Anytype_Model_Block.Content.Dataview.Relation.FormulaType = .none

        public var align: Anytype_Model_Block.Align = .left

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum DateFormat: SwiftProtobuf.Enum {
          public typealias RawValue = Int

          /// Jul 30, 2020
          case monthAbbrBeforeDay // = 0

          /// 30 Jul 2020
          case monthAbbrAfterDay // = 1

          /// 30/07/2020
          case short // = 2

          /// 07/30/2020
          case shortUs // = 3

          /// 2020-07-30
          case iso // = 4
          case UNRECOGNIZED(Int)

          public init() {
            self = .monthAbbrBeforeDay
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .monthAbbrBeforeDay
            case 1: self = .monthAbbrAfterDay
            case 2: self = .short
            case 3: self = .shortUs
            case 4: self = .iso
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .monthAbbrBeforeDay: return 0
            case .monthAbbrAfterDay: return 1
            case .short: return 2
            case .shortUs: return 3
            case .iso: return 4
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public enum TimeFormat: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case format12 // = 0
          case format24 // = 1
          case UNRECOGNIZED(Int)

          public init() {
            self = .format12
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .format12
            case 1: self = .format24
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .format12: return 0
            case .format24: return 1
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public enum FormulaType: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case none // = 0
          case count // = 1
          case countValue // = 2
          case countDistinct // = 3
          case countEmpty // = 4
          case countNotEmpty // = 5
          case percentEmpty // = 6
          case percentNotEmpty // = 7
          case mathSum // = 8
          case mathAverage // = 9
          case mathMedian // = 10
          case mathMin // = 11
          case mathMax // = 12
          case range // = 13
          case UNRECOGNIZED(Int)

          public init() {
            self = .none
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .none
            case 1: self = .count
            case 2: self = .countValue
            case 3: self = .countDistinct
            case 4: self = .countEmpty
            case 5: self = .countNotEmpty
            case 6: self = .percentEmpty
            case 7: self = .percentNotEmpty
            case 8: self = .mathSum
            case 9: self = .mathAverage
            case 10: self = .mathMedian
            case 11: self = .mathMin
            case 12: self = .mathMax
            case 13: self = .range
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .none: return 0
            case .count: return 1
            case .countValue: return 2
            case .countDistinct: return 3
            case .countEmpty: return 4
            case .countNotEmpty: return 5
            case .percentEmpty: return 6
            case .percentNotEmpty: return 7
            case .mathSum: return 8
            case .mathAverage: return 9
            case .mathMedian: return 10
            case .mathMin: return 11
            case .mathMax: return 12
            case .range: return 13
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public init() {}
      }

      public struct Sort {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var relationKey: String = String()

        public var type: Anytype_Model_Block.Content.Dataview.Sort.TypeEnum = .asc

        public var customOrder: [SwiftProtobuf.Google_Protobuf_Value] = []

        public var format: Anytype_Model_RelationFormat = .longtext

        public var includeTime: Bool = false

        public var id: String = String()

        public var emptyPlacement: Anytype_Model_Block.Content.Dataview.Sort.EmptyType = .notSpecified

        public var noCollate: Bool = false

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum TypeEnum: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case asc // = 0
          case desc // = 1
          case custom // = 2
          case UNRECOGNIZED(Int)

          public init() {
            self = .asc
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .asc
            case 1: self = .desc
            case 2: self = .custom
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .asc: return 0
            case .desc: return 1
            case .custom: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public enum EmptyType: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case notSpecified // = 0
          case start // = 1
          case end // = 2
          case UNRECOGNIZED(Int)

          public init() {
            self = .notSpecified
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .notSpecified
            case 1: self = .start
            case 2: self = .end
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .notSpecified: return 0
            case .start: return 1
            case .end: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public init() {}
      }

      public struct Filter {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var id: String = String()

        /// looks not applicable?
        public var `operator`: Anytype_Model_Block.Content.Dataview.Filter.Operator = .no

        public var relationKey: String = String()

        public var relationProperty: String = String()

        public var condition: Anytype_Model_Block.Content.Dataview.Filter.Condition = .none

        public var value: SwiftProtobuf.Google_Protobuf_Value {
          get {return _value ?? SwiftProtobuf.Google_Protobuf_Value()}
          set {_value = newValue}
        }
        /// Returns true if `value` has been explicitly set.
        public var hasValue: Bool {return self._value != nil}
        /// Clears the value of `value`. Subsequent reads from it will return its default value.
        public mutating func clearValue() {self._value = nil}

        public var quickOption: Anytype_Model_Block.Content.Dataview.Filter.QuickOption = .exactDate

        public var format: Anytype_Model_RelationFormat = .longtext

        public var includeTime: Bool = false

        public var nestedFilters: [Anytype_Model_Block.Content.Dataview.Filter] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum Operator: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case no // = 0
          case or // = 1
          case and // = 2
          case UNRECOGNIZED(Int)

          public init() {
            self = .no
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .no
            case 1: self = .or
            case 2: self = .and
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .no: return 0
            case .or: return 1
            case .and: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public enum Condition: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case none // = 0
          case equal // = 1
          case notEqual // = 2
          case greater // = 3
          case less // = 4
          case greaterOrEqual // = 5
          case lessOrEqual // = 6
          case like // = 7
          case notLike // = 8

          /// "at least one value(from the provided list) is IN"
          case `in` // = 9

          /// "none of provided values are IN"
          case notIn // = 10
          case empty // = 11
          case notEmpty // = 12
          case allIn // = 13
          case notAllIn // = 14
          case exactIn // = 15
          case notExactIn // = 16
          case exists // = 17
          case UNRECOGNIZED(Int)

          public init() {
            self = .none
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .none
            case 1: self = .equal
            case 2: self = .notEqual
            case 3: self = .greater
            case 4: self = .less
            case 5: self = .greaterOrEqual
            case 6: self = .lessOrEqual
            case 7: self = .like
            case 8: self = .notLike
            case 9: self = .in
            case 10: self = .notIn
            case 11: self = .empty
            case 12: self = .notEmpty
            case 13: self = .allIn
            case 14: self = .notAllIn
            case 15: self = .exactIn
            case 16: self = .notExactIn
            case 17: self = .exists
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .none: return 0
            case .equal: return 1
            case .notEqual: return 2
            case .greater: return 3
            case .less: return 4
            case .greaterOrEqual: return 5
            case .lessOrEqual: return 6
            case .like: return 7
            case .notLike: return 8
            case .in: return 9
            case .notIn: return 10
            case .empty: return 11
            case .notEmpty: return 12
            case .allIn: return 13
            case .notAllIn: return 14
            case .exactIn: return 15
            case .notExactIn: return 16
            case .exists: return 17
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public enum QuickOption: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case exactDate // = 0
          case yesterday // = 1
          case today // = 2
          case tomorrow // = 3
          case lastWeek // = 4
          case currentWeek // = 5
          case nextWeek // = 6
          case lastMonth // = 7
          case currentMonth // = 8
          case nextMonth // = 9
          case numberOfDaysAgo // = 10
          case numberOfDaysNow // = 11
          case UNRECOGNIZED(Int)

          public init() {
            self = .exactDate
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .exactDate
            case 1: self = .yesterday
            case 2: self = .today
            case 3: self = .tomorrow
            case 4: self = .lastWeek
            case 5: self = .currentWeek
            case 6: self = .nextWeek
            case 7: self = .lastMonth
            case 8: self = .currentMonth
            case 9: self = .nextMonth
            case 10: self = .numberOfDaysAgo
            case 11: self = .numberOfDaysNow
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          public var rawValue: Int {
            switch self {
            case .exactDate: return 0
            case .yesterday: return 1
            case .today: return 2
            case .tomorrow: return 3
            case .lastWeek: return 4
            case .currentWeek: return 5
            case .nextWeek: return 6
            case .lastMonth: return 7
            case .currentMonth: return 8
            case .nextMonth: return 9
            case .numberOfDaysAgo: return 10
            case .numberOfDaysNow: return 11
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        public init() {}

        fileprivate var _value: SwiftProtobuf.Google_Protobuf_Value? = nil
      }

      public struct GroupOrder {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var viewID: String = String()

        public var viewGroups: [Anytype_Model_Block.Content.Dataview.ViewGroup] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct ViewGroup {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var groupID: String = String()

        public var index: Int32 = 0

        public var hidden: Bool = false

        public var backgroundColor: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct ObjectOrder {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var viewID: String = String()

        public var groupID: String = String()

        public var objectIds: [String] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Group {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var id: String = String()

        public var value: Anytype_Model_Block.Content.Dataview.Group.OneOf_Value? = nil

        public var status: Anytype_Model_Block.Content.Dataview.Status {
          get {
            if case .status(let v)? = value {return v}
            return Anytype_Model_Block.Content.Dataview.Status()
          }
          set {value = .status(newValue)}
        }

        public var tag: Anytype_Model_Block.Content.Dataview.Tag {
          get {
            if case .tag(let v)? = value {return v}
            return Anytype_Model_Block.Content.Dataview.Tag()
          }
          set {value = .tag(newValue)}
        }

        public var checkbox: Anytype_Model_Block.Content.Dataview.Checkbox {
          get {
            if case .checkbox(let v)? = value {return v}
            return Anytype_Model_Block.Content.Dataview.Checkbox()
          }
          set {value = .checkbox(newValue)}
        }

        public var date: Anytype_Model_Block.Content.Dataview.Date {
          get {
            if case .date(let v)? = value {return v}
            return Anytype_Model_Block.Content.Dataview.Date()
          }
          set {value = .date(newValue)}
        }

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OneOf_Value: Equatable {
          case status(Anytype_Model_Block.Content.Dataview.Status)
          case tag(Anytype_Model_Block.Content.Dataview.Tag)
          case checkbox(Anytype_Model_Block.Content.Dataview.Checkbox)
          case date(Anytype_Model_Block.Content.Dataview.Date)

        #if !swift(>=4.1)
          public static func ==(lhs: Anytype_Model_Block.Content.Dataview.Group.OneOf_Value, rhs: Anytype_Model_Block.Content.Dataview.Group.OneOf_Value) -> Bool {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch (lhs, rhs) {
            case (.status, .status): return {
              guard case .status(let l) = lhs, case .status(let r) = rhs else { preconditionFailure() }
              return l == r
            }()
            case (.tag, .tag): return {
              guard case .tag(let l) = lhs, case .tag(let r) = rhs else { preconditionFailure() }
              return l == r
            }()
            case (.checkbox, .checkbox): return {
              guard case .checkbox(let l) = lhs, case .checkbox(let r) = rhs else { preconditionFailure() }
              return l == r
            }()
            case (.date, .date): return {
              guard case .date(let l) = lhs, case .date(let r) = rhs else { preconditionFailure() }
              return l == r
            }()
            default: return false
            }
          }
        #endif
        }

        public init() {}
      }

      public struct Status {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var id: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Tag {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var ids: [String] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Checkbox {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var checked: Bool = false

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Date {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public init() {}
    }    
}

extension Anytype_Model_Block.Content.Dataview.View.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Model_Block.Content.Dataview.View.TypeEnum] = [
    .table,
    .list,
    .gallery,
    .kanban,
    .calendar,
    .graph,
  ]
}

extension Anytype_Model_Block.Content.Dataview.View.Size: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Model_Block.Content.Dataview.View.Size] = [
    .small,
    .medium,
    .large,
  ]
}

extension Anytype_Model_Block.Content.Dataview.Relation.DateFormat: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Model_Block.Content.Dataview.Relation.DateFormat] = [
    .monthAbbrBeforeDay,
    .monthAbbrAfterDay,
    .short,
    .shortUs,
    .iso,
  ]
}

extension Anytype_Model_Block.Content.Dataview.Relation.TimeFormat: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Model_Block.Content.Dataview.Relation.TimeFormat] = [
    .format12,
    .format24,
  ]
}

extension Anytype_Model_Block.Content.Dataview.Relation.FormulaType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Model_Block.Content.Dataview.Relation.FormulaType] = [
    .none,
    .count,
    .countValue,
    .countDistinct,
    .countEmpty,
    .countNotEmpty,
    .percentEmpty,
    .percentNotEmpty,
    .mathSum,
    .mathAverage,
    .mathMedian,
    .mathMin,
    .mathMax,
    .range,
  ]
}

extension Anytype_Model_Block.Content.Dataview.Sort.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Model_Block.Content.Dataview.Sort.TypeEnum] = [
    .asc,
    .desc,
    .custom,
  ]
}

extension Anytype_Model_Block.Content.Dataview.Sort.EmptyType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Model_Block.Content.Dataview.Sort.EmptyType] = [
    .notSpecified,
    .start,
    .end,
  ]
}

extension Anytype_Model_Block.Content.Dataview.Filter.Operator: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Model_Block.Content.Dataview.Filter.Operator] = [
    .no,
    .or,
    .and,
  ]
}

extension Anytype_Model_Block.Content.Dataview.Filter.Condition: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Model_Block.Content.Dataview.Filter.Condition] = [
    .none,
    .equal,
    .notEqual,
    .greater,
    .less,
    .greaterOrEqual,
    .lessOrEqual,
    .like,
    .notLike,
    .in,
    .notIn,
    .empty,
    .notEmpty,
    .allIn,
    .notAllIn,
    .exactIn,
    .notExactIn,
    .exists,
  ]
}

extension Anytype_Model_Block.Content.Dataview.Filter.QuickOption: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anytype_Model_Block.Content.Dataview.Filter.QuickOption] = [
    .exactDate,
    .yesterday,
    .today,
    .tomorrow,
    .lastWeek,
    .currentWeek,
    .nextWeek,
    .lastMonth,
    .currentMonth,
    .nextMonth,
    .numberOfDaysAgo,
    .numberOfDaysNow,
  ]
}
extension Anytype_Model_Block.Content.Dataview: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.View: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.View.TypeEnum: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.View.Size: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.Relation: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.Relation.DateFormat: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.Relation.TimeFormat: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.Relation.FormulaType: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.Sort: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.Sort.TypeEnum: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.Sort.EmptyType: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.Filter: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.Filter.Operator: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.Filter.Condition: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.Filter.QuickOption: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.GroupOrder: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.ViewGroup: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.ObjectOrder: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.Group: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.Group.OneOf_Value: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.Status: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.Tag: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.Checkbox: @unchecked Sendable {}
extension Anytype_Model_Block.Content.Dataview.Date: @unchecked Sendable {}

extension Anytype_Model_Block.Content.Dataview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.protoMessageName + ".Dataview"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "views"),
    3: .same(proto: "activeView"),
    4: .same(proto: "relations"),
    12: .same(proto: "groupOrders"),
    13: .same(proto: "objectOrders"),
    5: .same(proto: "relationLinks"),
    6: .same(proto: "TargetObjectId"),
    14: .same(proto: "isCollection"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.source) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.views) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.activeView) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.relations) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.relationLinks) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.targetObjectID) }()
      case 12: try { try decoder.decodeRepeatedMessageField(value: &self.groupOrders) }()
      case 13: try { try decoder.decodeRepeatedMessageField(value: &self.objectOrders) }()
      case 14: try { try decoder.decodeSingularBoolField(value: &self.isCollection) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.source.isEmpty {
      try visitor.visitRepeatedStringField(value: self.source, fieldNumber: 1)
    }
    if !self.views.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.views, fieldNumber: 2)
    }
    if !self.activeView.isEmpty {
      try visitor.visitSingularStringField(value: self.activeView, fieldNumber: 3)
    }
    if !self.relations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.relations, fieldNumber: 4)
    }
    if !self.relationLinks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.relationLinks, fieldNumber: 5)
    }
    if !self.targetObjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetObjectID, fieldNumber: 6)
    }
    if !self.groupOrders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groupOrders, fieldNumber: 12)
    }
    if !self.objectOrders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.objectOrders, fieldNumber: 13)
    }
    if self.isCollection != false {
      try visitor.visitSingularBoolField(value: self.isCollection, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Dataview, rhs: Anytype_Model_Block.Content.Dataview) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.views != rhs.views {return false}
    if lhs.activeView != rhs.activeView {return false}
    if lhs.relations != rhs.relations {return false}
    if lhs.groupOrders != rhs.groupOrders {return false}
    if lhs.objectOrders != rhs.objectOrders {return false}
    if lhs.relationLinks != rhs.relationLinks {return false}
    if lhs.targetObjectID != rhs.targetObjectID {return false}
    if lhs.isCollection != rhs.isCollection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Dataview.View: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.Dataview.protoMessageName + ".View"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .same(proto: "name"),
    4: .same(proto: "sorts"),
    5: .same(proto: "filters"),
    6: .same(proto: "relations"),
    7: .same(proto: "coverRelationKey"),
    8: .same(proto: "hideIcon"),
    9: .same(proto: "cardSize"),
    10: .same(proto: "coverFit"),
    11: .same(proto: "groupRelationKey"),
    12: .same(proto: "groupBackgroundColors"),
    13: .same(proto: "pageLimit"),
    14: .same(proto: "defaultTemplateId"),
    15: .same(proto: "defaultObjectTypeId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.sorts) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.filters) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.relations) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.coverRelationKey) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.hideIcon) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.cardSize) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.coverFit) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.groupRelationKey) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.groupBackgroundColors) }()
      case 13: try { try decoder.decodeSingularInt32Field(value: &self.pageLimit) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.defaultTemplateID) }()
      case 15: try { try decoder.decodeSingularStringField(value: &self.defaultObjectTypeID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.type != .table {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.sorts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sorts, fieldNumber: 4)
    }
    if !self.filters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filters, fieldNumber: 5)
    }
    if !self.relations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.relations, fieldNumber: 6)
    }
    if !self.coverRelationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.coverRelationKey, fieldNumber: 7)
    }
    if self.hideIcon != false {
      try visitor.visitSingularBoolField(value: self.hideIcon, fieldNumber: 8)
    }
    if self.cardSize != .small {
      try visitor.visitSingularEnumField(value: self.cardSize, fieldNumber: 9)
    }
    if self.coverFit != false {
      try visitor.visitSingularBoolField(value: self.coverFit, fieldNumber: 10)
    }
    if !self.groupRelationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.groupRelationKey, fieldNumber: 11)
    }
    if self.groupBackgroundColors != false {
      try visitor.visitSingularBoolField(value: self.groupBackgroundColors, fieldNumber: 12)
    }
    if self.pageLimit != 0 {
      try visitor.visitSingularInt32Field(value: self.pageLimit, fieldNumber: 13)
    }
    if !self.defaultTemplateID.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultTemplateID, fieldNumber: 14)
    }
    if !self.defaultObjectTypeID.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultObjectTypeID, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Dataview.View, rhs: Anytype_Model_Block.Content.Dataview.View) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.name != rhs.name {return false}
    if lhs.sorts != rhs.sorts {return false}
    if lhs.filters != rhs.filters {return false}
    if lhs.relations != rhs.relations {return false}
    if lhs.coverRelationKey != rhs.coverRelationKey {return false}
    if lhs.hideIcon != rhs.hideIcon {return false}
    if lhs.cardSize != rhs.cardSize {return false}
    if lhs.coverFit != rhs.coverFit {return false}
    if lhs.groupRelationKey != rhs.groupRelationKey {return false}
    if lhs.groupBackgroundColors != rhs.groupBackgroundColors {return false}
    if lhs.pageLimit != rhs.pageLimit {return false}
    if lhs.defaultTemplateID != rhs.defaultTemplateID {return false}
    if lhs.defaultObjectTypeID != rhs.defaultObjectTypeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Dataview.View.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Table"),
    1: .same(proto: "List"),
    2: .same(proto: "Gallery"),
    3: .same(proto: "Kanban"),
    4: .same(proto: "Calendar"),
    5: .same(proto: "Graph"),
  ]
}

extension Anytype_Model_Block.Content.Dataview.View.Size: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Small"),
    1: .same(proto: "Medium"),
    2: .same(proto: "Large"),
  ]
}

extension Anytype_Model_Block.Content.Dataview.Relation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.Dataview.protoMessageName + ".Relation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "isVisible"),
    3: .same(proto: "width"),
    5: .same(proto: "dateIncludeTime"),
    6: .same(proto: "timeFormat"),
    7: .same(proto: "dateFormat"),
    8: .same(proto: "formula"),
    9: .same(proto: "align"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isVisible) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.dateIncludeTime) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.timeFormat) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.dateFormat) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.formula) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.align) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if self.isVisible != false {
      try visitor.visitSingularBoolField(value: self.isVisible, fieldNumber: 2)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 3)
    }
    if self.dateIncludeTime != false {
      try visitor.visitSingularBoolField(value: self.dateIncludeTime, fieldNumber: 5)
    }
    if self.timeFormat != .format12 {
      try visitor.visitSingularEnumField(value: self.timeFormat, fieldNumber: 6)
    }
    if self.dateFormat != .monthAbbrBeforeDay {
      try visitor.visitSingularEnumField(value: self.dateFormat, fieldNumber: 7)
    }
    if self.formula != .none {
      try visitor.visitSingularEnumField(value: self.formula, fieldNumber: 8)
    }
    if self.align != .left {
      try visitor.visitSingularEnumField(value: self.align, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Dataview.Relation, rhs: Anytype_Model_Block.Content.Dataview.Relation) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.isVisible != rhs.isVisible {return false}
    if lhs.width != rhs.width {return false}
    if lhs.dateIncludeTime != rhs.dateIncludeTime {return false}
    if lhs.timeFormat != rhs.timeFormat {return false}
    if lhs.dateFormat != rhs.dateFormat {return false}
    if lhs.formula != rhs.formula {return false}
    if lhs.align != rhs.align {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Dataview.Relation.DateFormat: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MonthAbbrBeforeDay"),
    1: .same(proto: "MonthAbbrAfterDay"),
    2: .same(proto: "Short"),
    3: .same(proto: "ShortUS"),
    4: .same(proto: "ISO"),
  ]
}

extension Anytype_Model_Block.Content.Dataview.Relation.TimeFormat: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Format12"),
    1: .same(proto: "Format24"),
  ]
}

extension Anytype_Model_Block.Content.Dataview.Relation.FormulaType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "None"),
    1: .same(proto: "Count"),
    2: .same(proto: "CountValue"),
    3: .same(proto: "CountDistinct"),
    4: .same(proto: "CountEmpty"),
    5: .same(proto: "CountNotEmpty"),
    6: .same(proto: "PercentEmpty"),
    7: .same(proto: "PercentNotEmpty"),
    8: .same(proto: "MathSum"),
    9: .same(proto: "MathAverage"),
    10: .same(proto: "MathMedian"),
    11: .same(proto: "MathMin"),
    12: .same(proto: "MathMax"),
    13: .same(proto: "Range"),
  ]
}

extension Anytype_Model_Block.Content.Dataview.Sort: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.Dataview.protoMessageName + ".Sort"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "RelationKey"),
    2: .same(proto: "type"),
    3: .same(proto: "customOrder"),
    4: .same(proto: "format"),
    5: .same(proto: "includeTime"),
    6: .same(proto: "id"),
    7: .same(proto: "emptyPlacement"),
    8: .same(proto: "noCollate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.relationKey) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.customOrder) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.includeTime) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.emptyPlacement) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.noCollate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.relationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.relationKey, fieldNumber: 1)
    }
    if self.type != .asc {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.customOrder.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.customOrder, fieldNumber: 3)
    }
    if self.format != .longtext {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 4)
    }
    if self.includeTime != false {
      try visitor.visitSingularBoolField(value: self.includeTime, fieldNumber: 5)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 6)
    }
    if self.emptyPlacement != .notSpecified {
      try visitor.visitSingularEnumField(value: self.emptyPlacement, fieldNumber: 7)
    }
    if self.noCollate != false {
      try visitor.visitSingularBoolField(value: self.noCollate, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Dataview.Sort, rhs: Anytype_Model_Block.Content.Dataview.Sort) -> Bool {
    if lhs.relationKey != rhs.relationKey {return false}
    if lhs.type != rhs.type {return false}
    if lhs.customOrder != rhs.customOrder {return false}
    if lhs.format != rhs.format {return false}
    if lhs.includeTime != rhs.includeTime {return false}
    if lhs.id != rhs.id {return false}
    if lhs.emptyPlacement != rhs.emptyPlacement {return false}
    if lhs.noCollate != rhs.noCollate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Dataview.Sort.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Asc"),
    1: .same(proto: "Desc"),
    2: .same(proto: "Custom"),
  ]
}

extension Anytype_Model_Block.Content.Dataview.Sort.EmptyType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NotSpecified"),
    1: .same(proto: "Start"),
    2: .same(proto: "End"),
  ]
}

extension Anytype_Model_Block.Content.Dataview.Filter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.Dataview.protoMessageName + ".Filter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    9: .same(proto: "id"),
    1: .same(proto: "operator"),
    2: .same(proto: "RelationKey"),
    5: .same(proto: "relationProperty"),
    3: .same(proto: "condition"),
    4: .same(proto: "value"),
    6: .same(proto: "quickOption"),
    7: .same(proto: "format"),
    8: .same(proto: "includeTime"),
    10: .same(proto: "nestedFilters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.`operator`) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.relationKey) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.condition) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.relationProperty) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.quickOption) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.includeTime) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.nestedFilters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.`operator` != .no {
      try visitor.visitSingularEnumField(value: self.`operator`, fieldNumber: 1)
    }
    if !self.relationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.relationKey, fieldNumber: 2)
    }
    if self.condition != .none {
      try visitor.visitSingularEnumField(value: self.condition, fieldNumber: 3)
    }
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.relationProperty.isEmpty {
      try visitor.visitSingularStringField(value: self.relationProperty, fieldNumber: 5)
    }
    if self.quickOption != .exactDate {
      try visitor.visitSingularEnumField(value: self.quickOption, fieldNumber: 6)
    }
    if self.format != .longtext {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 7)
    }
    if self.includeTime != false {
      try visitor.visitSingularBoolField(value: self.includeTime, fieldNumber: 8)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 9)
    }
    if !self.nestedFilters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nestedFilters, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Dataview.Filter, rhs: Anytype_Model_Block.Content.Dataview.Filter) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.`operator` != rhs.`operator` {return false}
    if lhs.relationKey != rhs.relationKey {return false}
    if lhs.relationProperty != rhs.relationProperty {return false}
    if lhs.condition != rhs.condition {return false}
    if lhs._value != rhs._value {return false}
    if lhs.quickOption != rhs.quickOption {return false}
    if lhs.format != rhs.format {return false}
    if lhs.includeTime != rhs.includeTime {return false}
    if lhs.nestedFilters != rhs.nestedFilters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Dataview.Filter.Operator: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "No"),
    1: .same(proto: "Or"),
    2: .same(proto: "And"),
  ]
}

extension Anytype_Model_Block.Content.Dataview.Filter.Condition: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "None"),
    1: .same(proto: "Equal"),
    2: .same(proto: "NotEqual"),
    3: .same(proto: "Greater"),
    4: .same(proto: "Less"),
    5: .same(proto: "GreaterOrEqual"),
    6: .same(proto: "LessOrEqual"),
    7: .same(proto: "Like"),
    8: .same(proto: "NotLike"),
    9: .same(proto: "In"),
    10: .same(proto: "NotIn"),
    11: .same(proto: "Empty"),
    12: .same(proto: "NotEmpty"),
    13: .same(proto: "AllIn"),
    14: .same(proto: "NotAllIn"),
    15: .same(proto: "ExactIn"),
    16: .same(proto: "NotExactIn"),
    17: .same(proto: "Exists"),
  ]
}

extension Anytype_Model_Block.Content.Dataview.Filter.QuickOption: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ExactDate"),
    1: .same(proto: "Yesterday"),
    2: .same(proto: "Today"),
    3: .same(proto: "Tomorrow"),
    4: .same(proto: "LastWeek"),
    5: .same(proto: "CurrentWeek"),
    6: .same(proto: "NextWeek"),
    7: .same(proto: "LastMonth"),
    8: .same(proto: "CurrentMonth"),
    9: .same(proto: "NextMonth"),
    10: .same(proto: "NumberOfDaysAgo"),
    11: .same(proto: "NumberOfDaysNow"),
  ]
}

extension Anytype_Model_Block.Content.Dataview.GroupOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.Dataview.protoMessageName + ".GroupOrder"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "viewId"),
    2: .same(proto: "viewGroups"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.viewID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.viewGroups) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.viewID.isEmpty {
      try visitor.visitSingularStringField(value: self.viewID, fieldNumber: 1)
    }
    if !self.viewGroups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.viewGroups, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Dataview.GroupOrder, rhs: Anytype_Model_Block.Content.Dataview.GroupOrder) -> Bool {
    if lhs.viewID != rhs.viewID {return false}
    if lhs.viewGroups != rhs.viewGroups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Dataview.ViewGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.Dataview.protoMessageName + ".ViewGroup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groupId"),
    2: .same(proto: "index"),
    3: .same(proto: "hidden"),
    4: .same(proto: "backgroundColor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.index) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.hidden) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.backgroundColor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularInt32Field(value: self.index, fieldNumber: 2)
    }
    if self.hidden != false {
      try visitor.visitSingularBoolField(value: self.hidden, fieldNumber: 3)
    }
    if !self.backgroundColor.isEmpty {
      try visitor.visitSingularStringField(value: self.backgroundColor, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Dataview.ViewGroup, rhs: Anytype_Model_Block.Content.Dataview.ViewGroup) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.index != rhs.index {return false}
    if lhs.hidden != rhs.hidden {return false}
    if lhs.backgroundColor != rhs.backgroundColor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Dataview.ObjectOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.Dataview.protoMessageName + ".ObjectOrder"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "viewId"),
    2: .same(proto: "groupId"),
    3: .same(proto: "objectIds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.viewID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.objectIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.viewID.isEmpty {
      try visitor.visitSingularStringField(value: self.viewID, fieldNumber: 1)
    }
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 2)
    }
    if !self.objectIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.objectIds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Dataview.ObjectOrder, rhs: Anytype_Model_Block.Content.Dataview.ObjectOrder) -> Bool {
    if lhs.viewID != rhs.viewID {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.objectIds != rhs.objectIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Dataview.Group: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.Dataview.protoMessageName + ".Group"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "status"),
    3: .same(proto: "tag"),
    4: .same(proto: "checkbox"),
    5: .same(proto: "date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try {
        var v: Anytype_Model_Block.Content.Dataview.Status?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .status(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .status(v)
        }
      }()
      case 3: try {
        var v: Anytype_Model_Block.Content.Dataview.Tag?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .tag(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .tag(v)
        }
      }()
      case 4: try {
        var v: Anytype_Model_Block.Content.Dataview.Checkbox?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .checkbox(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .checkbox(v)
        }
      }()
      case 5: try {
        var v: Anytype_Model_Block.Content.Dataview.Date?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .date(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .date(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    switch self.value {
    case .status?: try {
      guard case .status(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .tag?: try {
      guard case .tag(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .checkbox?: try {
      guard case .checkbox(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .date?: try {
      guard case .date(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Dataview.Group, rhs: Anytype_Model_Block.Content.Dataview.Group) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Dataview.Status: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.Dataview.protoMessageName + ".Status"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Dataview.Status, rhs: Anytype_Model_Block.Content.Dataview.Status) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Dataview.Tag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.Dataview.protoMessageName + ".Tag"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Dataview.Tag, rhs: Anytype_Model_Block.Content.Dataview.Tag) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Dataview.Checkbox: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.Dataview.protoMessageName + ".Checkbox"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "checked"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.checked) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.checked != false {
      try visitor.visitSingularBoolField(value: self.checked, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Dataview.Checkbox, rhs: Anytype_Model_Block.Content.Dataview.Checkbox) -> Bool {
    if lhs.checked != rhs.checked {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anytype_Model_Block.Content.Dataview.Date: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Anytype_Model_Block.Content.Dataview.protoMessageName + ".Date"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anytype_Model_Block.Content.Dataview.Date, rhs: Anytype_Model_Block.Content.Dataview.Date) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "anytype.model"
