// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: pkg/lib/pb/model/protos/models.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf
extension Anytype_Model_Block {

  public enum OneOf_Content: Equatable {
    case smartblock(Anytype_Model_Block.Content.Smartblock)
    case text(Anytype_Model_Block.Content.Text)
    case file(Anytype_Model_Block.Content.File)
    case layout(Anytype_Model_Block.Content.Layout)
    case div(Anytype_Model_Block.Content.Div)
    case bookmark(Anytype_Model_Block.Content.Bookmark)
    case icon(Anytype_Model_Block.Content.Icon)
    case link(Anytype_Model_Block.Content.Link)
    case dataview(Anytype_Model_Block.Content.Dataview)
    case relation(Anytype_Model_Block.Content.Relation)
    case featuredRelations(Anytype_Model_Block.Content.FeaturedRelations)
    case latex(Anytype_Model_Block.Content.Latex)
    case tableOfContents(Anytype_Model_Block.Content.TableOfContents)
    case table(Anytype_Model_Block.Content.Table)
    case tableColumn(Anytype_Model_Block.Content.TableColumn)
    case tableRow(Anytype_Model_Block.Content.TableRow)
    case widget(Anytype_Model_Block.Content.Widget)
    case chat(Anytype_Model_Block.Content.Chat)

  #if !swift(>=4.1)
    public static func ==(lhs: Anytype_Model_Block.OneOf_Content, rhs: Anytype_Model_Block.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.smartblock, .smartblock):
          return {
                  guard case .smartblock(let l) = lhs, case .smartblock(let r) = rhs else {
                      preconditionFailure()
                  }
                  return l == r
                }()
      case (.text, .text):
          return {
                  guard case .text(let l) = lhs, case .text(let r) = rhs else {
                      preconditionFailure()
                  }
                  return l == r
                }()
      case (.file, .file):
          return {
                  guard case .file(let l) = lhs, case .file(let r) = rhs else {
                      preconditionFailure()
                  }
                  return l == r
                }()
      case (.layout, .layout):
          return {
                  guard case .layout(let l) = lhs, case .layout(let r) = rhs else {
                      preconditionFailure()
                  }
                  return l == r
                }()
      case (.div, .div):
          return {
                  guard case .div(let l) = lhs, case .div(let r) = rhs else {
                      preconditionFailure()
                  }
                  return l == r
                }()
      case (.bookmark, .bookmark):
          return {
                  guard case .bookmark(let l) = lhs, case .bookmark(let r) = rhs else {
                      preconditionFailure()
                  }
                  return l == r
                }()
      case (.icon, .icon):
          return {
                  guard case .icon(let l) = lhs, case .icon(let r) = rhs else {
                      preconditionFailure()
                  }
                  return l == r
                }()
      case (.link, .link):
          return {
                  guard case .link(let l) = lhs, case .link(let r) = rhs else {
                      preconditionFailure()
                  }
                  return l == r
                }()
      case (.dataview, .dataview):
          return {
                  guard case .dataview(let l) = lhs, case .dataview(let r) = rhs else {
                      preconditionFailure()
                  }
                  return l == r
                }()
      case (.relation, .relation):
          return {
                  guard case .relation(let l) = lhs, case .relation(let r) = rhs else {
                      preconditionFailure()
                  }
                  return l == r
                }()
      case (.featuredRelations, .featuredRelations):
          return {
                  guard case .featuredRelations(let l) = lhs, case .featuredRelations(let r) = rhs else {
                      preconditionFailure()
                  }
                  return l == r
                }()
      case (.latex, .latex):
          return {
                  guard case .latex(let l) = lhs, case .latex(let r) = rhs else {
                      preconditionFailure()
                  }
                  return l == r
                }()
      case (.tableOfContents, .tableOfContents):
          return {
                  guard case .tableOfContents(let l) = lhs, case .tableOfContents(let r) = rhs else {
                      preconditionFailure()
                  }
                  return l == r
                }()
      case (.table, .table):
          return {
                  guard case .table(let l) = lhs, case .table(let r) = rhs else {
                      preconditionFailure()
                  }
                  return l == r
                }()
      case (.tableColumn, .tableColumn):
          return {
                  guard case .tableColumn(let l) = lhs, case .tableColumn(let r) = rhs else {
                      preconditionFailure()
                  }
                  return l == r
                }()
      case (.tableRow, .tableRow):
          return {
                  guard case .tableRow(let l) = lhs, case .tableRow(let r) = rhs else {
                      preconditionFailure()
                  }
                  return l == r
                }()
      case (.widget, .widget):
          return {
                  guard case .widget(let l) = lhs, case .widget(let r) = rhs else {
                      preconditionFailure()
                  }
                  return l == r
                }()
      case (.chat, .chat):
          return {
                  guard case .chat(let l) = lhs, case .chat(let r) = rhs else {
                      preconditionFailure()
                  }
                  return l == r
                }()
      default:
          return false
      }
    }
  #endif
  }
}
extension Anytype_Model_Block.OneOf_Content: @unchecked Sendable {
}

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {
  }
  typealias Version = _2
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "anytype.model"
